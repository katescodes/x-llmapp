"""
招投标应用 - 数据访问层 (DAO)
负责所有数据库操作，包括轻量级 KB 入库
"""
from __future__ import annotations

import json
import uuid
from typing import Any, Dict, List, Optional, Tuple

from psycopg.rows import dict_row
from psycopg_pool import ConnectionPool


def _id(prefix: str) -> str:
    """生成带前缀的UUID"""
    return f"{prefix}_{uuid.uuid4().hex}"


class TenderDAO:
    """招投标 DAO + 轻量 KB 入库"""

    def __init__(self, pool: ConnectionPool):
        """
        初始化 DAO
        
        Args:
            pool: PostgreSQL 连接池（同步）
        """
        self.pool = pool

    # ==================== 工具方法 ====================

    def _fetchone(self, sql: str, params: Tuple = ()) -> Optional[Dict[str, Any]]:
        """执行查询并返回单行"""
        with self.pool.connection() as conn:
            with conn.cursor(row_factory=dict_row) as cur:
                cur.execute(sql, params)
                return cur.fetchone()

    def _fetchall(self, sql: str, params: Tuple = ()) -> List[Dict[str, Any]]:
        """执行查询并返回所有行"""
        with self.pool.connection() as conn:
            with conn.cursor(row_factory=dict_row) as cur:
                cur.execute(sql, params)
                return list(cur.fetchall())

    def _execute(self, sql: str, params: Tuple = ()) -> None:
        """执行 SQL 语句（无返回值）"""
        with self.pool.connection() as conn:
            async with conn.cursor() as cur:
                await cur.execute(sql, params)
            await conn.commit()

    # ==================== 项目管理 ====================

    async def get_project(self, project_id: str) -> Optional[Dict[str, Any]]:
        """获取项目信息"""
        return await self._fetchone(
            "SELECT id, kb_id, name, description, created_at FROM tender_projects WHERE id=%s",
            (project_id,),
        )

    async def create_project(self, kb_id: str, name: str, description: Optional[str], owner_id: Optional[str]) -> Dict[str, Any]:
        """创建项目"""
        pid = _id("tp")
        row = await self._fetchone(
            """
            INSERT INTO tender_projects (id, kb_id, name, description, owner_id, created_at)
            VALUES (%s, %s, %s, %s, %s, NOW())
            RETURNING id, kb_id, name, description, owner_id, created_at
            """,
            (pid, kb_id, name, description, owner_id),
        )
        return row or {"id": pid, "kb_id": kb_id, "name": name, "description": description, "owner_id": owner_id}

    async def list_projects(self, owner_id: Optional[str]) -> List[Dict[str, Any]]:
        """列出项目（按owner_id过滤）"""
        if owner_id:
            return await self._fetchall(
                """
                SELECT id, kb_id, name, description, owner_id, created_at
                FROM tender_projects
                WHERE owner_id=%s
                ORDER BY created_at DESC
                """,
                (owner_id,),
            )
        return await self._fetchall(
            """
            SELECT id, kb_id, name, description, owner_id, created_at
            FROM tender_projects
            ORDER BY created_at DESC
            """,
            (),
        )

    # ==================== 任务运行管理 ====================

    async def create_run(self, project_id: str, kind: str) -> str:
        """创建运行任务"""
        rid = _id("tr")
        await self._execute(
            """
            INSERT INTO tender_runs (id, project_id, kind, status, progress, message, result_json, created_at, updated_at)
            VALUES (%s, %s, %s, 'pending', NULL, NULL, NULL, NOW(), NOW())
            """,
            (rid, project_id, kind),
        )
        return rid

    async def update_run(
        self,
        run_id: str,
        status: str,
        progress: Optional[float] = None,
        message: Optional[str] = None,
        result_json: Any = None,
    ):
        """更新运行任务状态"""
        await self._execute(
            """
            UPDATE tender_runs
            SET status=%s,
                progress=COALESCE(%s, progress),
                message=COALESCE(%s, message),
                result_json=COALESCE(%s, result_json),
                updated_at=NOW()
            WHERE id=%s
            """,
            (status, progress, message, json.dumps(result_json) if result_json is not None else None, run_id),
        )

    async def get_run(self, run_id: str) -> Optional[Dict[str, Any]]:
        """获取运行任务信息"""
        row = await self._fetchone("SELECT * FROM tender_runs WHERE id=%s", (run_id,))
        if row and isinstance(row.get("result_json"), str):
            try:
                row["result_json"] = json.loads(row["result_json"])
            except Exception:
                pass
        return row

    # ==================== 资产管理 ====================

    async def create_asset(
        self,
        project_id: str,
        kind: str,
        filename: Optional[str],
        mime_type: Optional[str],
        size_bytes: Optional[int],
        kb_doc_id: Optional[str],
        storage_path: Optional[str],
        bidder_name: Optional[str],
        meta_json: Dict[str, Any],
    ) -> Dict[str, Any]:
        """创建资产记录"""
        aid = _id("ta")
        row = await self._fetchone(
            """
            INSERT INTO tender_project_assets
              (id, project_id, kind, filename, mime_type, size_bytes, kb_doc_id, storage_path, bidder_name, meta_json, created_at)
            VALUES
              (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s::jsonb, NOW())
            RETURNING *
            """,
            (aid, project_id, kind, filename, mime_type, size_bytes, kb_doc_id, storage_path, bidder_name, json.dumps(meta_json or {})),
        )
        return row or {}

    async def list_assets(self, project_id: str) -> List[Dict[str, Any]]:
        """列出项目的所有资产"""
        return await self._fetchall(
            "SELECT * FROM tender_project_assets WHERE project_id=%s ORDER BY created_at ASC",
            (project_id,),
        )

    async def get_assets_by_ids(self, project_id: str, asset_ids: List[str]) -> List[Dict[str, Any]]:
        """根据ID列表获取资产"""
        if not asset_ids:
            return []
        placeholders = ",".join(["%s"] * len(asset_ids))
        return await self._fetchall(
            f"SELECT * FROM tender_project_assets WHERE project_id=%s AND id IN ({placeholders})",
            tuple([project_id] + asset_ids),
        )

    # ==================== 规则集管理 ====================

    async def create_rule_set(
        self,
        project_id: str,
        name: str,
        description: Optional[str],
        source_asset_ids: List[str],
        rules_json: Any,
    ) -> Dict[str, Any]:
        """创建规则集"""
        rid = _id("trs")
        row = await self._fetchone(
            """
            INSERT INTO tender_custom_rule_sets
              (id, project_id, name, description, source_asset_ids_json, rules_json, created_at)
            VALUES
              (%s, %s, %s, %s, %s::jsonb, %s::jsonb, NOW())
            RETURNING *
            """,
            (rid, project_id, name, description, json.dumps(source_asset_ids or []), json.dumps(rules_json)),
        )
        return row or {}

    async def list_rule_sets(self, project_id: str) -> List[Dict[str, Any]]:
        """列出项目的所有规则集"""
        rows = await self._fetchall(
            "SELECT * FROM tender_custom_rule_sets WHERE project_id=%s ORDER BY created_at DESC",
            (project_id,),
        )
        # JSON 字段反序列化
        for r in rows:
            for k in ("source_asset_ids_json", "rules_json"):
                if isinstance(r.get(k), str):
                    try:
                        r[k] = json.loads(r[k])
                    except Exception:
                        pass
        return rows

    async def get_rule_sets_by_ids(self, project_id: str, ids: List[str]) -> List[Dict[str, Any]]:
        """根据ID列表获取规则集"""
        if not ids:
            return []
        placeholders = ",".join(["%s"] * len(ids))
        rows = await self._fetchall(
            f"SELECT * FROM tender_custom_rule_sets WHERE project_id=%s AND id IN ({placeholders})",
            tuple([project_id] + ids),
        )
        # JSON 字段反序列化
        for r in rows:
            for k in ("source_asset_ids_json", "rules_json"):
                if isinstance(r.get(k), str):
                    try:
                        r[k] = json.loads(r[k])
                    except Exception:
                        pass
        return rows

    # ==================== KB 轻量入库 ====================

    async def create_kb_document(
        self,
        kb_id: str,
        filename: str,
        content_hash: str,
        meta_json: Dict[str, Any],
        kb_category: str = "tender_app",
    ) -> str:
        """创建 KB 文档记录"""
        doc_id = _id("doc")
        await self._execute(
            """
            INSERT INTO kb_documents (id, kb_id, filename, source, content_hash, status, kb_category, created_at, updated_at, meta_json)
            VALUES (%s, %s, %s, %s, %s, 'ready', %s, NOW(), NOW(), %s::jsonb)
            """,
            (doc_id, kb_id, filename, f"upload://{filename}", content_hash, kb_category, json.dumps(meta_json or {})),
        )
        return doc_id

    async def insert_kb_chunks(
        self,
        kb_id: str,
        doc_id: str,
        chunks: List[Dict[str, Any]],
        kb_category: str = "tender_app",
    ) -> List[str]:
        """批量插入 KB chunks"""
        chunk_ids: List[str] = []
        async with self.pool.connection() as conn:
            async with conn.cursor() as cur:
                for c in chunks:
                    cid = _id("chunk")
                    chunk_ids.append(cid)
                    title = c.get("title") or ""
                    url = c.get("url") or ""
                    position = int(c.get("position") or 0)
                    content = c.get("content") or ""
                    await cur.execute(
                        """
                        INSERT INTO kb_chunks (chunk_id, kb_id, doc_id, title, url, position, content, kb_category, created_at, tsv)
                        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, NOW(), to_tsvector('simple', %s))
                        """,
                        (cid, kb_id, doc_id, title, url, position, content, kb_category, content),
                    )
            await conn.commit()
        return chunk_ids

    async def lookup_chunks(self, chunk_ids: List[str]) -> List[Dict[str, Any]]:
        """根据 chunk_ids 查询 chunks"""
        if not chunk_ids:
            return []
        placeholders = ",".join(["%s"] * len(chunk_ids))
        return await self._fetchall(
            f"""
            SELECT chunk_id, doc_id, title, url, position, content
            FROM kb_chunks
            WHERE chunk_id IN ({placeholders})
            """,
            tuple(chunk_ids),
        )

    async def load_chunks_by_doc_ids(self, doc_ids: List[str], limit: int) -> List[Dict[str, Any]]:
        """根据 doc_ids 加载 chunks"""
        if not doc_ids:
            return []
        placeholders = ",".join(["%s"] * len(doc_ids))
        return await self._fetchall(
            f"""
            SELECT chunk_id, doc_id, title, url, position, content
            FROM kb_chunks
            WHERE doc_id IN ({placeholders})
            ORDER BY doc_id ASC, position ASC
            LIMIT %s
            """,
            tuple(doc_ids + [limit]),
        )

    # ==================== 项目信息 ====================

    async def upsert_project_info(
        self,
        project_id: str,
        data_json: Dict[str, Any],
        evidence_chunk_ids: List[str],
    ):
        """插入或更新项目信息"""
        await self._execute(
            """
            INSERT INTO tender_project_info (id, project_id, data_json, evidence_chunk_ids_json, updated_at)
            VALUES (%s, %s, %s::jsonb, %s::jsonb, NOW())
            ON CONFLICT (project_id) DO UPDATE SET
              data_json=EXCLUDED.data_json,
              evidence_chunk_ids_json=EXCLUDED.evidence_chunk_ids_json,
              updated_at=NOW()
            """,
            (_id("tpi"), project_id, json.dumps(data_json or {}), json.dumps(evidence_chunk_ids or [])),
        )

    async def get_project_info(self, project_id: str) -> Optional[Dict[str, Any]]:
        """获取项目信息"""
        row = await self._fetchone(
            "SELECT project_id, data_json, evidence_chunk_ids_json, updated_at FROM tender_project_info WHERE project_id=%s",
            (project_id,),
        )
        if not row:
            return None
        # JSON 字段反序列化
        for k in ("data_json", "evidence_chunk_ids_json"):
            if isinstance(row.get(k), str):
                try:
                    row[k] = json.loads(row[k])
                except Exception:
                    pass
        return row

    # ==================== 风险管理 ====================

    async def replace_risks(self, project_id: str, items: List[Dict[str, Any]]):
        """替换项目的所有风险"""
        async with self.pool.connection() as conn:
            async with conn.cursor() as cur:
                await cur.execute("DELETE FROM tender_risks WHERE project_id=%s", (project_id,))
                for it in items:
                    await cur.execute(
                        """
                        INSERT INTO tender_risks
                          (id, project_id, risk_type, title, description, suggestion, severity, tags_json, evidence_chunk_ids_json, created_at)
                        VALUES
                          (%s, %s, %s, %s, %s, %s, %s, %s::jsonb, %s::jsonb, NOW())
                        """,
                        (
                            _id("risk"),
                            project_id,
                            it.get("risk_type"),
                            it.get("title"),
                            it.get("description"),
                            it.get("suggestion"),
                            it.get("severity"),
                            json.dumps(it.get("tags") or []),
                            json.dumps(it.get("evidence_chunk_ids") or []),
                        ),
                    )
            await conn.commit()

    async def list_risks(self, project_id: str) -> List[Dict[str, Any]]:
        """列出项目的所有风险"""
        rows = await self._fetchall(
            "SELECT * FROM tender_risks WHERE project_id=%s ORDER BY created_at ASC",
            (project_id,),
        )
        # JSON 字段反序列化
        for r in rows:
            for k in ("tags_json", "evidence_chunk_ids_json"):
                if isinstance(r.get(k), str):
                    try:
                        r[k] = json.loads(r[k])
                    except Exception:
                        pass
        return rows

    # ==================== 目录管理 ====================

    async def replace_directory(self, project_id: str, nodes: List[Dict[str, Any]]):
        """替换项目的整个目录"""
        async with self.pool.connection() as conn:
            async with conn.cursor() as cur:
                await cur.execute("DELETE FROM tender_directory_nodes WHERE project_id=%s", (project_id,))
                for n in nodes:
                    await cur.execute(
                        """
                        INSERT INTO tender_directory_nodes
                          (id, project_id, numbering, level, title, required, notes, evidence_chunk_ids_json, created_at)
                        VALUES
                          (%s, %s, %s, %s, %s, %s, %s, %s::jsonb, NOW())
                        """,
                        (
                            _id("dir"),
                            project_id,
                            n.get("numbering"),
                            int(n.get("level") or 1),
                            n.get("title"),
                            bool(n.get("required", True)),
                            n.get("notes"),
                            json.dumps(n.get("evidence_chunk_ids") or []),
                        ),
                    )
            await conn.commit()

    async def list_directory(self, project_id: str) -> List[Dict[str, Any]]:
        """列出项目的目录结构"""
        rows = await self._fetchall(
            "SELECT numbering, level, title, required, notes, evidence_chunk_ids_json FROM tender_directory_nodes WHERE project_id=%s ORDER BY created_at ASC",
            (project_id,),
        )
        # JSON 字段反序列化
        for r in rows:
            if isinstance(r.get("evidence_chunk_ids_json"), str):
                try:
                    r["evidence_chunk_ids_json"] = json.loads(r["evidence_chunk_ids_json"])
                except Exception:
                    pass
        return rows

    # ==================== 审核项管理 ====================

    async def replace_review_items(self, project_id: str, items: List[Dict[str, Any]]):
        """替换项目的所有审核项"""
        async with self.pool.connection() as conn:
            async with conn.cursor() as cur:
                await cur.execute("DELETE FROM tender_review_items WHERE project_id=%s", (project_id,))
                for it in items:
                    await cur.execute(
                        """
                        INSERT INTO tender_review_items
                          (id, project_id, dimension, requirement_text, response_text, result, remark, rigid,
                           tender_evidence_chunk_ids_json, bid_evidence_chunk_ids_json, created_at)
                        VALUES
                          (%s, %s, %s, %s, %s, %s, %s, %s, %s::jsonb, %s::jsonb, NOW())
                        """,
                        (
                            _id("rev"),
                            project_id,
                            it.get("dimension") or "其他",
                            it.get("requirement_text"),
                            it.get("response_text"),
                            it.get("result"),
                            it.get("remark"),
                            bool(it.get("rigid", False)),
                            json.dumps(it.get("tender_evidence_chunk_ids") or []),
                            json.dumps(it.get("bid_evidence_chunk_ids") or []),
                        ),
                    )
            await conn.commit()

    async def list_review_items(self, project_id: str) -> List[Dict[str, Any]]:
        """列出项目的所有审核项"""
        rows = await self._fetchall(
            "SELECT * FROM tender_review_items WHERE project_id=%s ORDER BY created_at ASC",
            (project_id,),
        )
        # JSON 字段反序列化
        for r in rows:
            for k in ("tender_evidence_chunk_ids_json", "bid_evidence_chunk_ids_json"):
                if isinstance(r.get(k), str):
                    try:
                        r[k] = json.loads(r[k])
                    except Exception:
                        pass
        return rows

    # ==================== 兼容旧 API ====================

    async def create_project_document_binding(
        self,
        project_id: str,
        role: str,
        kb_doc_id: str,
        bidder_name: Optional[str],
        filename: Optional[str],
    ):
        """创建项目文档绑定（兼容旧 API）"""
        bid = _id("tpd")
        await self._execute(
            """
            INSERT INTO tender_project_documents (id, project_id, role, kb_doc_id, bidder_name, filename, created_at)
            VALUES (%s, %s, %s, %s, %s, %s, NOW())
            """,
            (bid, project_id, role, kb_doc_id, bidder_name, filename),
        )

    async def list_project_documents(self, project_id: str) -> List[Dict[str, Any]]:
        """列出项目文档绑定（兼容旧 API）"""
        return await self._fetchall(
            """
            SELECT id, project_id, role, kb_doc_id, bidder_name, filename, created_at
            FROM tender_project_documents
            WHERE project_id=%s
            ORDER BY created_at ASC
            """,
            (project_id,),
        )
