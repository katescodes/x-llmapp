"""
招投标应用 - REST API 路由
提供所有 HTTP 接口
"""
from __future__ import annotations

from typing import List, Optional

from fastapi import APIRouter, BackgroundTasks, Depends, File, Form, HTTPException, Request, UploadFile
from fastapi.responses import Response
from psycopg_pool import ConnectionPool

from app.schemas.tender import (
    AssetOut,
    ChunkLookupReq,
    DirectorySaveReq,
    ExtractReq,
    ProjectCreateReq,
    ProjectInfoOut,
    ProjectOut,
    ReviewItemOut,
    ReviewRunReq,
    RiskOut,
    RuleSetExtractReq,
    RuleSetOut,
    RunOut,
)
from app.services.dao.tender_dao import TenderDAO
from app.services.tender_service import TenderService
from app.services import kb_service
from app.utils.auth import get_current_user

# 创建路由器
router = APIRouter(prefix="/api/apps/tender", tags=["tender"])


# ==================== 依赖注入 ====================

def _get_pool(req: Request) -> ConnectionPool:
    """从 postgres 模块获取连接池"""
    from app.services.db.postgres import _get_pool as get_sync_pool
    return get_sync_pool()


def _get_llm(req: Request):
    """从 app.state 获取 LLM orchestrator"""
    llm = getattr(req.app.state, "llm_orchestrator", None)
    if llm is None:
        raise HTTPException(status_code=500, detail="LLM orchestrator not initialized on app.state")
    return llm


def _svc(req: Request) -> TenderService:
    """创建 TenderService 实例"""
    dao = TenderDAO(_get_pool(req))
    return TenderService(dao=dao, llm_orchestrator=_get_llm(req))


# ==================== 项目管理 ====================

@router.post("/projects", response_model=ProjectOut)
async def create_project(req: ProjectCreateReq, request: Request, user=Depends(get_current_user)):
    """创建项目（自动创建KB）"""
    # 1. 先创建知识库
    kb_id = kb_service.create_kb(
        name=f"招投标-{req.name}",
        description=req.description or f"招投标项目：{req.name}",
        category_id="cat_knowledge"  # 使用正确的分类ID
    )
    
    # 2. 创建项目并关联KB
    dao = TenderDAO(_get_pool(request))
    row = await dao.create_project(kb_id, req.name, req.description, owner_id=user.user_id)
    return row


@router.get("/projects", response_model=List[ProjectOut])
async def list_projects(request: Request, user=Depends(get_current_user)):
    """列出当前用户的所有项目"""
    dao = TenderDAO(_get_pool(request))
    return await dao.list_projects(owner_id=user.user_id)


@router.get("/projects/{project_id}/documents")
async def list_legacy_documents(project_id: str, request: Request):
    """列出项目文档绑定（兼容旧 API）"""
    dao = TenderDAO(_get_pool(request))
    return await dao.list_project_documents(project_id)


# ==================== 资产管理 ====================

@router.get("/projects/{project_id}/assets", response_model=List[AssetOut])
async def list_assets(project_id: str, request: Request):
    """列出项目的所有资产"""
    svc = _svc(request)
    return await svc.list_assets(project_id)


@router.post("/projects/{project_id}/assets/import", response_model=List[AssetOut])
async def import_assets(
    project_id: str,
    request: Request,
    kind: str = Form(...),  # tender | bid | template | custom_rule
    bidder_name: Optional[str] = Form(None),
    files: List[UploadFile] = File(...),
):
    """
    项目内上传文件并自动绑定
    
    Args:
        kind: 文件类型（tender/bid/template/custom_rule）
        bidder_name: 投标人名称（kind=bid 时必填）
        files: 上传的文件列表
    """
    # 参数校验
    if kind not in ("tender", "bid", "template", "custom_rule"):
        raise HTTPException(status_code=400, detail="invalid kind")
    if kind == "bid" and not (bidder_name or "").strip():
        raise HTTPException(status_code=400, detail="bidder_name required for bid")
    
    svc = _svc(request)
    try:
        return await svc.import_assets(project_id, kind, files, bidder_name)
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


# ==================== 运行任务管理 ====================

@router.get("/runs/{run_id}", response_model=RunOut)
async def get_run(run_id: str, request: Request):
    """获取运行任务状态"""
    dao = TenderDAO(_get_pool(request))
    row = await dao.get_run(run_id)
    if not row:
        raise HTTPException(status_code=404, detail="run not found")
    return row


# ==================== 项目信息抽取 ====================

@router.post("/projects/{project_id}/extract/project-info")
async def extract_project_info(
    project_id: str,
    req: ExtractReq,
    request: Request,
    bg: BackgroundTasks,
):
    """抽取项目信息"""
    dao = TenderDAO(_get_pool(request))
    run_id = await dao.create_run(project_id, "extract_project_info")
    await dao.update_run(run_id, "running", progress=0.01, message="running")
    svc = _svc(request)

    async def job():
        try:
            await svc.extract_project_info(project_id, req.model_id, run_id=run_id)
        except Exception as e:
            await dao.update_run(run_id, "failed", message=str(e))

    bg.add_task(job)
    return {"run_id": run_id}


@router.get("/projects/{project_id}/project-info", response_model=Optional[ProjectInfoOut])
async def get_project_info(project_id: str, request: Request):
    """获取项目信息"""
    dao = TenderDAO(_get_pool(request))
    row = await dao.get_project_info(project_id)
    if not row:
        return None
    return {
        "project_id": row["project_id"],
        "data_json": row.get("data_json") or {},
        "evidence_chunk_ids": row.get("evidence_chunk_ids_json") or [],
        "updated_at": row.get("updated_at"),
    }


# ==================== 风险识别 ====================

@router.post("/projects/{project_id}/extract/risks")
async def extract_risks(
    project_id: str,
    req: ExtractReq,
    request: Request,
    bg: BackgroundTasks,
):
    """识别风险"""
    dao = TenderDAO(_get_pool(request))
    run_id = await dao.create_run(project_id, "extract_risks")
    await dao.update_run(run_id, "running", progress=0.01, message="running")
    svc = _svc(request)

    async def job():
        try:
            await svc.extract_risks(project_id, req.model_id, run_id=run_id)
        except Exception as e:
            await dao.update_run(run_id, "failed", message=str(e))

    bg.add_task(job)
    return {"run_id": run_id}


@router.get("/projects/{project_id}/risks", response_model=List[RiskOut])
async def list_risks(project_id: str, request: Request):
    """列出风险"""
    dao = TenderDAO(_get_pool(request))
    rows = await dao.list_risks(project_id)
    out = []
    for r in rows:
        out.append(
            {
                "id": r["id"],
                "project_id": r["project_id"],
                "risk_type": r["risk_type"],
                "title": r["title"],
                "description": r.get("description"),
                "suggestion": r.get("suggestion"),
                "severity": r.get("severity"),
                "tags": r.get("tags_json") or [],
                "evidence_chunk_ids": r.get("evidence_chunk_ids_json") or [],
            }
        )
    return out


# ==================== 目录生成 ====================

@router.post("/projects/{project_id}/directory/generate")
async def generate_directory(
    project_id: str,
    req: ExtractReq,
    request: Request,
    bg: BackgroundTasks,
):
    """生成目录"""
    dao = TenderDAO(_get_pool(request))
    run_id = await dao.create_run(project_id, "generate_directory")
    await dao.update_run(run_id, "running", progress=0.01, message="running")
    svc = _svc(request)

    async def job():
        try:
            await svc.generate_directory(project_id, req.model_id, run_id=run_id)
        except Exception as e:
            await dao.update_run(run_id, "failed", message=str(e))

    bg.add_task(job)
    return {"run_id": run_id}


@router.get("/projects/{project_id}/directory")
async def get_directory(project_id: str, request: Request):
    """获取目录"""
    dao = TenderDAO(_get_pool(request))
    rows = await dao.list_directory(project_id)
    return [
        {
            "numbering": r["numbering"],
            "level": r["level"],
            "title": r["title"],
            "required": r["required"],
            "notes": r.get("notes"),
            "evidence_chunk_ids": r.get("evidence_chunk_ids_json") or [],
        }
        for r in rows
    ]


@router.put("/projects/{project_id}/directory")
async def save_directory(project_id: str, req: DirectorySaveReq, request: Request):
    """保存目录（用户编辑后）"""
    svc = _svc(request)
    await svc.save_directory(project_id, [n.dict() for n in req.nodes])
    return {"ok": True}


# ==================== 规则集管理 ====================

@router.get("/projects/{project_id}/rule-sets", response_model=List[RuleSetOut])
async def list_rule_sets(project_id: str, request: Request):
    """列出规则集"""
    svc = _svc(request)
    rows = await svc.list_rule_sets(project_id)
    out = []
    for r in rows:
        out.append(
            {
                "id": r["id"],
                "project_id": r["project_id"],
                "name": r["name"],
                "description": r.get("description"),
                "source_asset_ids": r.get("source_asset_ids_json") or [],
                "rules_json": r.get("rules_json") or [],
                "created_at": r.get("created_at"),
            }
        )
    return out


@router.post("/projects/{project_id}/rule-sets/extract")
async def extract_rule_set(
    project_id: str,
    req: RuleSetExtractReq,
    request: Request,
    bg: BackgroundTasks,
):
    """从规则文件抽取规则集"""
    if not req.source_asset_ids:
        raise HTTPException(status_code=400, detail="source_asset_ids required")
    
    dao = TenderDAO(_get_pool(request))
    run_id = await dao.create_run(project_id, "extract_rule_set")
    await dao.update_run(run_id, "running", progress=0.01, message="running")
    svc = _svc(request)

    async def job():
        try:
            await svc.extract_rule_set(
                project_id,
                req.name,
                req.description,
                req.source_asset_ids,
                req.model_id,
                run_id=run_id,
            )
        except Exception as e:
            await dao.update_run(run_id, "failed", message=str(e))

    bg.add_task(job)
    return {"run_id": run_id}


# ==================== 审核 ====================

@router.post("/projects/{project_id}/review/run")
async def run_review(
    project_id: str,
    req: ReviewRunReq,
    request: Request,
    bg: BackgroundTasks,
):
    """
    运行审核（招标规则 + 自定义规则集叠加）
    
    Args:
        req.custom_rule_set_ids: 自定义规则集ID列表（多选叠加）
        req.bidder_name: 投标人名称（选择投标人）
        req.bid_asset_ids: 投标资产ID列表（精确指定文件）
    """
    dao = TenderDAO(_get_pool(request))
    run_id = await dao.create_run(project_id, "review")
    await dao.update_run(run_id, "running", progress=0.01, message="running")
    svc = _svc(request)

    async def job():
        try:
            await svc.run_review(
                project_id,
                req.model_id,
                req.custom_rule_set_ids,
                req.bidder_name,
                req.bid_asset_ids,
                run_id=run_id,
            )
        except Exception as e:
            await dao.update_run(run_id, "failed", message=str(e))

    bg.add_task(job)
    return {"run_id": run_id}


@router.get("/projects/{project_id}/review", response_model=List[ReviewItemOut])
async def get_review(project_id: str, request: Request):
    """获取审核结果"""
    dao = TenderDAO(_get_pool(request))
    rows = await dao.list_review_items(project_id)
    out = []
    for r in rows:
        out.append(
            {
                "id": r["id"],
                "project_id": r["project_id"],
                "dimension": r.get("dimension") or "其他",
                "requirement_text": r.get("requirement_text"),
                "response_text": r.get("response_text"),
                "result": r.get("result") or "risk",
                "remark": r.get("remark"),
                "rigid": bool(r.get("rigid", False)),
                "tender_evidence_chunk_ids": r.get("tender_evidence_chunk_ids_json") or [],
                "bid_evidence_chunk_ids": r.get("bid_evidence_chunk_ids_json") or [],
            }
        )
    return out


# ==================== 文档生成 ====================

@router.post("/projects/{project_id}/docx")
async def gen_docx(
    project_id: str,
    request: Request,
    template_asset_id: Optional[str] = None,
):
    """
    生成 Word 文档
    
    Args:
        template_asset_id: 模板资产ID（可选）
    """
    svc = _svc(request)
    data = await svc.generate_docx(project_id, template_asset_id)
    return Response(
        content=data,
        media_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    )


# ==================== Chunk 查询（证据回溯） ====================

@router.post("/chunks/lookup")
async def chunks_lookup(req: ChunkLookupReq, request: Request):
    """查询 chunks（证据回溯）"""
    svc = _svc(request)
    rows = await svc.lookup_chunks(req.chunk_ids)
    # 输出给前端 SourcePanel
    return [
        {
            "chunk_id": r["chunk_id"],
            "doc_id": r["doc_id"],
            "title": r.get("title") or "",
            "url": r.get("url") or "",
            "position": r.get("position") or 0,
            "content": r.get("content") or "",
        }
        for r in rows
    ]
